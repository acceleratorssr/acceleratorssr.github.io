---
layout: post
title: Lecture2 & lab1
tags: 2021MIT6.824
excerpt: 2021 L2 && 2022 lab1
---

# 2021 L2
<a href="https://acceleratorssr.github.io/2024/06/19/GC">go的垃圾回收机制</a>

使用线程所遇到的挑战
1. 线程的竞态条件，解决方法：
● 通过避免使用共享内存，而是使用channel；
● 使用锁；
1. 协调
● 使用channel或者条件变量
1. 死锁

# 2022 Lab1
遇到的小问题：生成的中间文件要删掉；

总体流程：

&emsp;&emsp;map 任务放入 channel，工人从协调器处 channel 取任务（保证并发安全），由协调器决定当前阶段为 map 还是 reduce，工人处理并按照 ihash 分桶后保存在本地后发起完成任务的rpc，协调器将对应任务id的数组置为 完成任务 状态；在协调器发出任务时，启动一个定时器，并且开一个goroutine监听，如果接受任务的map崩溃了，没有在10s内返回 ack，则协调器将对应任务重新放入队列供其他工人拿取，并重复流程；工人返回done给协调器后，协调器直接在done数组置位，只可能false -> true，不可能反过来；当最后协调器没有任务，但是ack还没收集完时，其他work的请求会返回一个waiting的状态，work会sleep1s；
&emsp;&emsp;reduce阶段和map类似，完成map后将对应任务放入channel中，一样的处理，使用的done数组和map阶段的是同一个（一开始make时直接取reduce的大小），完成后删除中间文件，并退出，工作线程不会收到结束信号，当它连接不上协调器时默认任务结束，就关闭了；

老师（好像是助教）的解法：

&emsp;&emsp;发任务直接加锁后，遍历数组拿对应编号；
&emsp;&emsp;条件变量让协调器等待，因为代码的RPC调用没有设置超时时间，所以当协调器c.cond.Wait()时，工人会阻塞等待rpc的返回，相比于work循环发起rpc，减少网络流量，效果是一样的；
&emsp;&emsp;关于读写加锁的问题：写有锁，但是读没锁时，会发生数据竞争 --> 是因为当两个或多个 goroutine 同时访问同一块内存区域，并且至少有一个是写操作时，如果没有正确的同步操作来确保它们之间的正确执行顺序，会导致未定义的行为。